---
title: "VAR Selection"
output: html_notebook
---

# Chargement des librairies

```{r}
# install.packages("MultiVarSel_1.0.tar.gz",repos=NULL)
library(MultiVarSel)
library(reshape)
library(ggplot2)
library(knitr)
library(FactoMineR)
library(factoextra)
library(dplyr)
```

# Import des données

```{r}
table<-read.table("../Table_proteome_FH_all.csv", sep=";", dec=",", header=T,row.names=1)
dim(table)
```

## Ajout du facteur temperature pour caractériser les echantillons

```{r}
### Creation d'une variable qualitative supplementaire pour enlever les replicats
temperature<-factor(rep(c("Low","Medium","Elevated"),each=3),levels=c("Low","Medium","Elevated"))
imbibition<-factor(rep(c("DS", "EI", "LI"), each=3), levels=c("DS", "EI", "LI"))
```

## Vérification de la présence de col dont les valeures ne bougent jamais et d'éventuelles données manquantes
```{r}
which(is.na(table))
```


# Construction de la matrice

```{r}
table2 <- table[,c(3:ncol(table))]
Y <- as.matrix(table2[, -(1:2)])
X1 <- table2[, 1]
X2 <- table2[, 2]
```

```{r}
table(X1,X2)
```
We build the design matrix

```{r}
X <- model.matrix(lm(Y ~ (X2 + X1) + 0))
p <- ncol(X)
n=nrow(X)
q=dim(Y)[2]
```

# Analyse descriptive

## heatmap

```{r}
jpeg(file="./images/heatmap.jpg")
heatmap(abs(cor(table2[,-c(1,2)])), symm=TRUE)
dev.off()
```

## ACP

```{r}
acp.res=PCA(Y, scale.unit = TRUE, ncp = dim(Y)[2], graph = FALSE)
fviz_pca_ind(acp.res
            , geom.ind = "point"
            , col.ind=X2
            , palette=c("blue", "darkgreen", "orange")
            , legend.title = "imbibition"
            , addEllipses = T
            , ellipse.level = 0.4
            )
ggsave("./images/imbibition_pca.png", bg = "white")
```
```{r}

fviz_pca_ind(acp.res
             , geom.ind = "point"
             , col.ind=X1
             , palette=c("blue", "darkgreen", "orange")
             , legend.title = "Température"
             , addEllipses = T
             , ellipse.level = 0.4
             )
ggsave("./images/temperature_pca.png", bg = "white")
```
## Boxplot

```{r}
coord12=acp.res$ind$coord[,c(1,2)]
jpeg(file="./images/imbibition_boxplot.jpeg")
boxplot(coord12[,1]~X2,col="red", main = "imbibition dim 1")
dev.off()
ggsave("./images/imbibition_boxplot.png", bg = "white")
boxplot(coord12[,2]~X2,col="red", main = "imbibition dim 2")
jpeg(file="./images/temperature_boxplot.jpeg")
boxplot(coord12[,1]~X1,col="red", main = "temperature dim 1")
dev.off()
boxplot(coord12[,2]~X1,col="red", main = "temperature dim 2")
```
# Anova séparée, métabolite par métabolite

```{r}
select_per_anova=c()
for(i in 3:ncol(table2)){
  res.anova<-lm(table2[,i]~table2[,2], data=table2)
  pvalue.anova=c()
  pvalue.anova<-anova(res.anova)$'Pr(>F)'[1]
  if(pvalue.anova<0.05/q){
    select_per_anova=c(select_per_anova,colnames(table2)[i])}}
length(select_per_anova)
```

# Etude du modèle multivarié

We scale the Y matrix

```{r}
Yscaled=scale(Y)
Y=Yscaled
```

(i) sans blanchiment

```{r}
Yvec=as.numeric(Y)
Xvec=kronecker(diag(q),X)
length(Yvec)
```
```{r}
dim(Xvec)
```
## 10-fold Cross-validation method to choose lambda

```{r}
resultat_cv=cv.glmnet(Xvec,Yvec,nfolds=10,family="gaussian",alpha=1,grouped=FALSE)
lambda_min=resultat_cv$lambda.min
```

## Stability Selection (it may take time)

```{r}
nb_repli=50
stabsel.glmnet <- function(i) 
  {
    b_sort <- sort(sample(1:(n*q),floor((n*q)/2)))
    resultat_glmnet=glmnet(Xvec[b_sort,],Yvec[b_sort],family="gaussian",alpha=1,lambda=lambda_min)
    ind_glmnet=which(resultat_glmnet$beta!=0)
    return(tabulate(ind_glmnet,(p*q)))
  }
  res.cum <- Reduce("+", lapply(1:nb_repli, stabsel.glmnet))
```

## Variable selection (threshold = 1 to control the false positive rate)

```{r}
ind=which((res.cum/nb_repli)==1)
length(ind) # beaucoup trop ...
```
## (ii) avec blanchiment

The residuals are defined as follows:

```{r}
residuals=lm(as.matrix(Y)~X-1)$residuals
```

We apply the whitening test to this residuals matrix in order to know if it is useful to whiten the observations
or not

```{r}
pvalue=whitening_test(residuals)
pvalue
```

P-value est supérieur à 0,05 mais par précaution on préferera voir s'il y a des structures de dépendance qui s'adepte mieux à nos données.


```{r}
result=whitening_choice(residuals,c("AR1","nonparam","ARMA"),pAR=1,qMA=1)
result
```

The non parametric choice has the highest p-value. We select this dependence to model the residuals. We
compute the square root of the inverse of the estimator of the covariance matrix of each row of the residuals
matrix using the non parametric modelling as follows:

```{r}
square_root_inv_hat_Sigma=whitening(residuals,"nonparam",pAR=1,qMA=0)
```

## Fréquences patimonieuse des "betas"

```{r}
library(parallel)
require(doMC)
Freqs2=variable_selection(Y,X,square_root_inv_hat_Sigma, nb_repli=5000,parallel=FALSE,nb.cores=2)
```


```{r}
save(Freqs2, file='./tables_output/Freqs_proteome_nbreplis_5000_X2_2022.Rdata')
```


We then applied the variable selection technique. Here, in order to provide an example having a low
computational burden, we only applied the stability selection with 100 replications. We suggest to the reader
to take at least 500 replicates to have a robust result.


```{r}
library(parallel)
require(doMC)
registerDoMC(cores=1)
Frequencies=variable_selection(Y,X,square_root_inv_hat_Sigma,nb_repli=5000,parallel=TRUE,nb.cores=1)
```

This function provides the selection frequencies of the variables for the different levels of the qualitative
variable. To display the positions of the metabolites that are selected with a frequency larger than 95%, the
following code can be used.


```{r}
load('./tables_output/Freqs_proteome_nbreplis_1000_X1_X2_2022.Rdata')
```

```{r}
colnames(Freqs2)<-c('Names_of_Y','Names_of_X','frequency') 
plot(sort(Freqs2$frequency,decreasing = T),type='s')
```


```{r}
sort(Freqs2$frequency,decreasing = T)[1:50]
```


```{r}
seuil=0.99
Freqs2$Names_of_X=gsub(pattern='temperature',replacement='',Freqs2$Names_of_X)
indices=which(Freqs2$frequency>=seuil)
length(indices)
Yvec=as.numeric(Y%*%square_root_inv_hat_Sigma) 
Xvec=kronecker(t(square_root_inv_hat_Sigma),X) 
Xvec_sel=as.matrix(Xvec[,indices]) 
B_sel_hat=solve(t(Xvec_sel)%*%Xvec_sel,t(Xvec_sel)%*%Yvec) 
Freqs2$estim=rep(0,p*q) 
Freqs2$estim[indices]=as.vector(B_sel_hat)
```

```{r}
gr<-ggplot(data=Freqs2[Freqs2$frequency>=seuil,], 
           aes(x=Names_of_Y,y=Names_of_X,color=estim))+
        scale_color_gradient2(low="steelblue",mid = "white", high ="red")+  
    geom_point(size=2)+theme_bw()+ylab('Temperature')+xlab('Proteins')+theme(axis.text.x = element_text(angle=90))
gr
```


```{r}
Name = Freqs2$Names_of_Y[Freqs2$frequency>=seuil]
Name
for (i in Name){
  table3 <- table2$i}
```


```{r}
Name=Freqs2$Names_of_Y[Freqs2$frequency>=seuil]
```


```{r}

table_red=as.data.frame(Y[,colnames(Y)%in%unique(Freqs2[indices,]$Names_of_Y)])

table_red$temperature=table2[,1]
bp <- ggplot(melt(table_red), aes(x=temperature, y=value,fill=temperature)) + 
  geom_boxplot()+theme_bw()
```

```{r}
bp+facet_wrap(~variable,ncol=4)+ylab("Réponse")
```








